<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>游꿛 Paint Pixel</title> <link rel="stylesheet" href="styles.css">
</head>
<body>

    <div id="controls">
        <h3>Paint Pixel</h3> <label for="colorPicker">Color:</label>
        <input type="color" id="colorPicker" value="#000000">

        <button id="drawButton" class="tool-active">L치piz</button>
        <button id="eraserButton">Borrador</button>
        <button id="fillButton">Rellenar</button>

        <label for="gridSize">Tama침o P칤xel (px):</label>
        <input type="number" id="gridSize" value="10" min="1" max="50">

        <button id="clearButton">Limpiar</button>
        
        <button id="downloadButton">拘勇 Descargar Dibujo</button>
        <button id="publishButton">游댕 Publicar / Compartir</button>
    </div>

    <canvas id="hiddenCanvas" style="display: none;"></canvas>

    <div id="drawing-board">
        </div>

    <script src="script.js"></script>
</body>
</html><style>body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: #f4f4f9;
    margin: 0;
    padding: 20px 10px; 
}

#controls {
    background-color: #fff;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap; 
    justify-content: center;
}

#controls h3 {
    margin: 0;
    margin-right: 10px;
    color: #333;
}

#controls label {
    font-weight: bold;
    font-size: 0.9em;
}

#controls input[type="color"] {
    width: 40px;
    height: 30px;
    border: 1px solid #ccc;
    padding: 0;
    cursor: pointer;
}

#controls input[type="number"] {
    width: 50px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

#controls button {
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
    color: white; /* Color de texto por defecto para botones */
}

/* Estilos de herramientas */
#drawButton, #eraserButton, #fillButton {
    background-color: #6c757d; 
}
.tool-active {
    background-color: #28a745 !important; /* Verde para herramienta activa */
}

/* Estilo del bot칩n Limpiar */
#clearButton {
    background-color: #dc3545;
}
#clearButton:hover {
    background-color: #c82333;
}

/* Estilo del bot칩n Descargar */
#downloadButton {
    background-color: #007bff;
}
#downloadButton:hover {
    background-color: #0056b3;
}

/* Tablero de dibujo (RESPONSIVO) */
#drawing-board {
    background-color: #ffffff;
    border: 1px solid #aaa;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    
    /* Dimensiones responsivas: m치ximo 500px, pero usa 90% de la ventana en m칩vil */
    width: min(500px, 90vw); 
    height: min(500px, 90vw);
    display: flex; 
    flex-wrap: wrap; 
    cursor: crosshair;
    touch-action: none; /* Crucial para evitar zoom y scroll en t치ctil */
}

.pixel {
    box-sizing: border-box;
}</style><script>document.addEventListener('DOMContentLoaded', () => {
    // URL de tu servidor de Discord.
    const DISCORD_INVITE_URL = "https://discord.gg/94s7ebEP3Z";

    // Referencias a elementos del DOM
    const drawingBoard = document.getElementById('drawing-board');
    const colorPicker = document.getElementById('colorPicker');
    const gridSizeInput = document.getElementById('gridSize');
    const clearButton = document.getElementById('clearButton');
    const drawButton = document.getElementById('drawButton');
    const eraserButton = document('eraserButton');
    const fillButton = document.getElementById('fillButton');
    const downloadButton = document.getElementById('downloadButton');
    const publishButton = document.getElementById('publishButton'); 
    
    const hiddenCanvas = document.getElementById('hiddenCanvas');
    const ctx = hiddenCanvas.getContext('2d'); 

    // Variables de estado
    let initialDrawColor = colorPicker.value; 
    let currentColor = initialDrawColor;
    let currentTool = 'draw'; 
    let isDrawing = false;
    let pixelSize = parseInt(gridSizeInput.value); 
    let allPixels = []; 
    let pixelsPerSide = 0; 

    // --- FUNCIONES CORE ---
    
    /** Genera el Data URL de la imagen (PNG) a partir de los divs */
    function generateImageDataURL() {
        if (allPixels.length === 0) return null;

        const boardDimension = drawingBoard.clientWidth;
        const effectiveSize = allPixels[0] ? allPixels[0].clientWidth : 10; 

        hiddenCanvas.width = boardDimension;
        hiddenCanvas.height = boardDimension;
        
        allPixels.forEach(pixel => {
            const x = parseInt(pixel.dataset.x);
            const y = parseInt(pixel.dataset.y);
            const color = pixel.style.backgroundColor;

            ctx.fillStyle = color;
            ctx.fillRect(x * effectiveSize, y * effectiveSize, effectiveSize, effectiveSize);
        });

        return hiddenCanvas.toDataURL('image/png');
    }

    /** 1. Descarga la imagen como archivo PNG (Guarda el dibujo) */
    function downloadDrawing() {
        const imageURL = generateImageDataURL();
        if (!imageURL) {
            alert("No hay nada que descargar.");
            return false;
        }
        
        const link = document.createElement('a');
        link.href = imageURL;
        link.download = 'paint-pixel-art.png';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        return true; // 칄xito en la descarga
    }

    /** 2. Publica la imagen: Guarda Y Redirige a Discord */
    function publishDrawing() {
        // PASO 1: GUARDA EL DIBUJO
        if (!downloadDrawing()) {
            return; 
        }

        // PASO 2: REDIRIGE AL SERVER DE DISCORD (despu칠s de la confirmaci칩n)
        if (confirm("춰Tu obra se ha descargado! Ser치s redirigido a la comunidad de Discord para subir tu archivo 'paint-pixel-art.png' manualmente. 쮺ontinuar?")) {
            // Abre la invitaci칩n de Discord en una nueva pesta침a
            window.open(DISCORD_INVITE_URL, '_blank');
        }
    }

    
    // --- L칍GICA DE DIBUJO (Mantenida sin cambios) ---
    
    /** Genera la cuadr칤cula de p칤xeles (divs) */
    function generateGrid(size) {
        const boardFixedSize = drawingBoard.clientWidth || 500; 
        drawingBoard.innerHTML = '';
        
        pixelsPerSide = Math.floor(boardFixedSize / size);
        const effectiveSize = boardFixedSize / pixelsPerSide; 

        const numPixels = pixelsPerSide * pixelsPerSide;
        allPixels = []; 
        
        for (let i = 0; i < numPixels; i++) {
            const pixel = document.createElement('div');
            pixel.classList.add('pixel');
            pixel.dataset.index = i; 
            
            pixel.style.width = `${effectiveSize}px`;
            pixel.style.height = `${effectiveSize}px`;
            pixel.style.backgroundColor = '#ffffff'; 
            
            allPixels.push(pixel);
            drawingBoard.appendChild(pixel);
        }

        addGridCoordinates(pixelsPerSide);
        addDrawingListeners();
    }

    /** Asigna coordenadas (x, y) a cada p칤xel */
    function addGridCoordinates(pSide) {
        allPixels.forEach((pixel, index) => {
            const x = index % pSide;
            const y = Math.floor(index / pSide);
            pixel.dataset.x = x;
            pixel.dataset.y = y;
        });
    }

    /** Cambia el color de un p칤xel */
    function colorPixel(element) {
        if (element && element.classList.contains('pixel')) {
            element.style.backgroundColor = currentColor;
        }
    }

    /** Obtiene el elemento bajo la posici칩n t치ctil */
    function getTouchedElement(touch) {
        return document.elementFromPoint(touch.clientX, touch.clientY);
    }
    
    /** L칩gica de Relleno (Flood Fill Algorithm) */
    function floodFill(startElement) {
        if (!startElement || !startElement.classList.contains('pixel')) return;

        const targetColor = startElement.style.backgroundColor;
        const fillColor = currentColor;

        if (targetColor === fillColor) return;

        const pSide = Math.sqrt(allPixels.length);
        const queue = [startElement];
        const visitedIndices = new Set();
        
        const getPixel = (x, y) => {
            if (x >= 0 && x < pSide && y >= 0 && y < pSide) {
                const index = y * pSide + x;
                return allPixels[index];
            }
            return null;
        };
        
        while (queue.length > 0) {
            const currentPixel = queue.shift();
            const index = currentPixel.dataset.index;

            if (visitedIndices.has(index) || currentPixel.style.backgroundColor !== targetColor) {
                continue;
            }
            
            currentPixel.style.backgroundColor = fillColor;
            visitedIndices.add(index);
            
            const x = parseInt(currentPixel.dataset.x);
            const y = parseInt(currentPixel.dataset.y);
            
            const neighbors = [
                getPixel(x, y - 1), getPixel(x, y + 1), getPixel(x - 1, y), getPixel(x + 1, y)  
            ];
            
            neighbors.forEach(neighbor => {
                if (neighbor && 
                    neighbor.style.backgroundColor === targetColor && 
                    !visitedIndices.has(neighbor.dataset.index)) {
                    queue.push(neighbor);
                }
            });
        }
    }

    /** Maneja la acci칩n de dibujo/relleno */
    function handleAction(element) {
        if (!element || !element.classList.contains('pixel')) return;
        if (currentTool === 'fill') {
            floodFill(element);
        } else {
            colorPixel(element);
        }
    }

    /** Agrega los escuchadores de eventos (Rat칩n y T치ctil) */
    function addDrawingListeners() {
        // EVENTOS DE RAT칍N
        drawingBoard.onmousedown = (e) => {
            isDrawing = (currentTool !== 'fill'); 
            handleAction(e.target);
        };
        document.onmouseup = () => { isDrawing = false; };
        drawingBoard.onmouseover = (e) => { if (isDrawing) { handleAction(e.target); } };
        
        // EVENTOS T츼CTILES
        drawingBoard.ontouchstart = (e) => {
            e.preventDefault(); 
            isDrawing = (currentTool !== 'fill');
            const touch = e.touches[0];
            handleAction(getTouchedElement(touch));
        };
        drawingBoard.ontouchmove = (e) => {
            e.preventDefault(); 
            if (isDrawing) {
                const touch = e.touches[0];
                handleAction(getTouchedElement(touch));
            }
        };
        drawingBoard.ontouchend = () => { isDrawing = false; };
    }

    // --- Escuchadores de Control ---

    /** Maneja la selecci칩n de herramientas */
    function selectTool(tool) {
        currentTool = tool;
        const buttons = [drawButton, eraserButton, fillButton];
        buttons.forEach(btn => btn.classList.remove('tool-active'));

        if (tool === 'draw') {
            currentColor = initialDrawColor;
            drawButton.classList.add('tool-active');
        } else if (tool === 'erase') {
            currentColor = '#ffffff'; 
            eraserButton.classList.add('tool-active');
        } else if (tool === 'fill') {
            currentColor = initialDrawColor; 
            fillButton.classList.add('tool-active');
        }
    }

    // Eventos de botones de herramientas
    drawButton.addEventListener('click', () => selectTool('draw'));
    eraserButton.addEventListener('click', () => selectTool('erase'));
    fillButton.addEventListener('click', () => selectTool('fill'));

    // Eventos de descarga y publicaci칩n
    downloadButton.addEventListener('click', downloadDrawing); 
    publishButton.addEventListener('click', publishDrawing); 

    // Eventos de color, limpieza, tama침o y redimensionamiento
    colorPicker.addEventListener('input', (e) => {
        initialDrawColor = e.target.value;
        if (currentTool !== 'erase') { currentColor = initialDrawColor; }
    });

    clearButton.addEventListener('click', () => {
        const pixels = document.querySelectorAll('.pixel');
        pixels.forEach(pixel => { pixel.style.backgroundColor = '#ffffff'; });
    });

    gridSizeInput.addEventListener('change', (e) => {
        let newSize = parseInt(e.target.value);
        if (newSize < 1 || newSize > 50) { newSize = 10; gridSizeInput.value = 10; }
        pixelSize = newSize;
        generateGrid(pixelSize);
    });

    window.addEventListener('resize', () => { generateGrid(pixelSize); });

    // --- Inicializaci칩n ---
    generateGrid(pixelSize);
});</script>