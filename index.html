<meta name='viewport' content='width=device-width, initial-scale=1'/><!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Paint Sin Canvas (Exportable)</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>

    <div id="controls">
        <h3>Controles</h3>
        
        <label for="colorPicker">Color:</label>
        <input type="color" id="colorPicker" value="#000000">

        <button id="drawButton" class="tool-active">Lápiz</button>
        <button id="eraserButton">Borrador</button>
        <button id="fillButton">Rellenar</button>

        <label for="gridSize">Tamaño Píxel (px):</label>
        <input type="number" id="gridSize" value="10" min="1" max="50">

        <button id="clearButton">Limpiar</button>
        <button id="downloadButton">⬇️ Descargar Dibujo</button>
    </div>

    <canvas id="hiddenCanvas" style="display: none;"></canvas>

    <div id="drawing-board">
        </div>

    <script src="script.js"></script>
</body>
</html><style>body {
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: #f4f4f9;
    margin: 0;
    padding: 20px 10px; 
}

#controls {
    background-color: #fff;
    padding: 15px;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
    display: flex;
    gap: 10px;
    align-items: center;
    flex-wrap: wrap; 
    justify-content: center;
}

#controls h3 {
    margin: 0;
    margin-right: 10px;
    color: #333;
}

#controls label {
    font-weight: bold;
    font-size: 0.9em;
}

#controls input[type="color"] {
    width: 40px;
    height: 30px;
    border: 1px solid #ccc;
    padding: 0;
    cursor: pointer;
}

#controls input[type="number"] {
    width: 50px;
    padding: 5px;
    border: 1px solid #ccc;
    border-radius: 4px;
}

#controls button {
    padding: 8px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.3s;
    color: white; /* Color de texto por defecto para botones */
}

/* Estilos de herramientas */
#drawButton, #eraserButton, #fillButton {
    background-color: #6c757d; 
}
.tool-active {
    background-color: #28a745 !important; /* Verde para herramienta activa */
}

/* Estilo del botón Limpiar */
#clearButton {
    background-color: #dc3545;
}
#clearButton:hover {
    background-color: #c82333;
}

/* Estilo del botón Descargar */
#downloadButton {
    background-color: #007bff;
}
#downloadButton:hover {
    background-color: #0056b3;
}

/* Tablero de dibujo (RESPONSIVO) */
#drawing-board {
    background-color: #ffffff;
    border: 1px solid #aaa;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
    
    /* Dimensiones responsivas: máximo 500px, pero usa 90% de la ventana en móvil */
    width: min(500px, 90vw); 
    height: min(500px, 90vw);
    display: flex; 
    flex-wrap: wrap; 
    cursor: crosshair;
    touch-action: none; /* Crucial para evitar zoom y scroll en táctil */
}

.pixel {
    box-sizing: border-box;
}</style><script>document.addEventListener('DOMContentLoaded', () => {
    // Referencias a elementos del DOM
    const drawingBoard = document.getElementById('drawing-board');
    const colorPicker = document.getElementById('colorPicker');
    const gridSizeInput = document.getElementById('gridSize');
    const clearButton = document.getElementById('clearButton');
    const drawButton = document.getElementById('drawButton');
    const eraserButton = document.getElementById('eraserButton');
    const fillButton = document.getElementById('fillButton');
    const downloadButton = document.getElementById('downloadButton');
    
    const hiddenCanvas = document.getElementById('hiddenCanvas');
    const ctx = hiddenCanvas.getContext('2d'); 

    // Variables de estado
    let initialDrawColor = colorPicker.value; 
    let currentColor = initialDrawColor;
    let currentTool = 'draw'; 
    let isDrawing = false;
    let pixelSize = parseInt(gridSizeInput.value); 
    let allPixels = []; 
    let pixelsPerSide = 0; 

    // --------------------------------------------------------
    // --- FUNCIÓN DE DESCARGA (EXPORTA DIVS A PNG) ---
    // --------------------------------------------------------
    function downloadDrawing() {
        if (allPixels.length === 0) return;

        // 1. Obtener dimensiones y tamaño efectivo del píxel
        const boardDimension = drawingBoard.clientWidth;
        // Asumimos que todos los píxeles tienen el mismo tamaño
        const effectiveSize = allPixels[0] ? allPixels[0].clientWidth : 10; 

        // 2. Configurar el Canvas oculto
        hiddenCanvas.width = boardDimension;
        hiddenCanvas.height = boardDimension;
        
        // 3. Dibujar cada "píxel" (div) en el Canvas
        allPixels.forEach(pixel => {
            const x = parseInt(pixel.dataset.x);
            const y = parseInt(pixel.dataset.y);
            const color = pixel.style.backgroundColor;

            // Dibujar el rectángulo del píxel
            ctx.fillStyle = color;
            ctx.fillRect(x * effectiveSize, y * effectiveSize, effectiveSize, effectiveSize);
        });

        // 4. Crear el enlace de descarga (PNG)
        const imageURL = hiddenCanvas.toDataURL('image/png');
        
        const link = document.createElement('a');
        link.href = imageURL;
        link.download = 'mi-dibujo-pixel-art.png';
        
        // Simular un clic
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
    // --------------------------------------------------------


    // --- Funciones de Lógica Principal ---
    
    /** 1. Genera la cuadrícula de píxeles (divs) */
    function generateGrid(size) {
        const boardFixedSize = drawingBoard.clientWidth || 500; 
        
        drawingBoard.innerHTML = '';
        
        pixelsPerSide = Math.floor(boardFixedSize / size);
        const effectiveSize = boardFixedSize / pixelsPerSide; 

        const numPixels = pixelsPerSide * pixelsPerSide;
        allPixels = []; 
        
        for (let i = 0; i < numPixels; i++) {
            const pixel = document.createElement('div');
            pixel.classList.add('pixel');
            pixel.dataset.index = i; 
            
            // Asignar tamaño y coordenadas
            pixel.style.width = `${effectiveSize}px`;
            pixel.style.height = `${effectiveSize}px`;
            pixel.style.backgroundColor = '#ffffff'; 
            
            allPixels.push(pixel);
            drawingBoard.appendChild(pixel);
        }

        addGridCoordinates(pixelsPerSide);
        addDrawingListeners();
    }

    /** Asigna coordenadas (x, y) a cada píxel para el Flood Fill */
    function addGridCoordinates(pSide) {
        allPixels.forEach((pixel, index) => {
            const x = index % pSide;
            const y = Math.floor(index / pSide);
            pixel.dataset.x = x;
            pixel.dataset.y = y;
        });
    }

    /** Cambia el color de un píxel */
    function colorPixel(element) {
        if (element && element.classList.contains('pixel')) {
            element.style.backgroundColor = currentColor;
        }
    }

    /** Obtiene el elemento bajo la posición táctil */
    function getTouchedElement(touch) {
        return document.elementFromPoint(touch.clientX, touch.clientY);
    }
    
    /** Lógica de Relleno (Flood Fill Algorithm) */
    function floodFill(startElement) {
        if (!startElement || !startElement.classList.contains('pixel')) return;

        const targetColor = startElement.style.backgroundColor;
        const fillColor = currentColor;

        if (targetColor === fillColor) return;

        const pSide = Math.sqrt(allPixels.length);
        const queue = [startElement];
        const visitedIndices = new Set();
        
        const getPixel = (x, y) => {
            if (x >= 0 && x < pSide && y >= 0 && y < pSide) {
                const index = y * pSide + x;
                return allPixels[index];
            }
            return null;
        };
        
        while (queue.length > 0) {
            const currentPixel = queue.shift();
            const index = currentPixel.dataset.index;

            if (visitedIndices.has(index) || currentPixel.style.backgroundColor !== targetColor) {
                continue;
            }
            
            currentPixel.style.backgroundColor = fillColor;
            visitedIndices.add(index);
            
            const x = parseInt(currentPixel.dataset.x);
            const y = parseInt(currentPixel.dataset.y);
            
            const neighbors = [
                getPixel(x, y - 1), getPixel(x, y + 1), getPixel(x - 1, y), getPixel(x + 1, y)  
            ];
            
            neighbors.forEach(neighbor => {
                if (neighbor && 
                    neighbor.style.backgroundColor === targetColor && 
                    !visitedIndices.has(neighbor.dataset.index)) {
                    queue.push(neighbor);
                }
            });
        }
    }


    /** Maneja la acción de dibujo/relleno */
    function handleAction(element) {
        if (!element || !element.classList.contains('pixel')) return;

        if (currentTool === 'fill') {
            floodFill(element);
        } else {
            colorPixel(element);
        }
    }

    /** Agrega los escuchadores de eventos (Ratón y Táctil) */
    function addDrawingListeners() {
        
        // EVENTOS DE RATÓN
        drawingBoard.onmousedown = (e) => {
            isDrawing = (currentTool !== 'fill'); 
            handleAction(e.target);
        };

        document.onmouseup = () => {
            isDrawing = false;
        };

        drawingBoard.onmouseover = (e) => {
            if (isDrawing) {
                handleAction(e.target);
            }
        };
        
        // EVENTOS TÁCTILES
        drawingBoard.ontouchstart = (e) => {
            e.preventDefault(); 
            isDrawing = (currentTool !== 'fill');
            const touch = e.touches[0];
            handleAction(getTouchedElement(touch));
        };

        drawingBoard.ontouchmove = (e) => {
            e.preventDefault(); 
            if (isDrawing) {
                const touch = e.touches[0];
                handleAction(getTouchedElement(touch));
            }
        };
        
        drawingBoard.ontouchend = () => {
            isDrawing = false;
        };
    }

    // --- Escuchadores de Control ---

    /** Maneja la selección de herramientas */
    function selectTool(tool) {
        currentTool = tool;
        const buttons = [drawButton, eraserButton, fillButton];
        buttons.forEach(btn => btn.classList.remove('tool-active'));

        if (tool === 'draw') {
            currentColor = initialDrawColor;
            drawButton.classList.add('tool-active');
        } else if (tool === 'erase') {
            currentColor = '#ffffff'; 
            eraserButton.classList.add('tool-active');
        } else if (tool === 'fill') {
            currentColor = initialDrawColor; 
            fillButton.classList.add('tool-active');
        }
    }

    // Eventos de botones de herramientas
    drawButton.addEventListener('click', () => selectTool('draw'));
    eraserButton.addEventListener('click', () => selectTool('erase'));
    fillButton.addEventListener('click', () => selectTool('fill'));

    // Evento del botón de descarga
    downloadButton.addEventListener('click', downloadDrawing); 

    // Eventos de color, limpieza, tamaño y redimensionamiento
    colorPicker.addEventListener('input', (e) => {
        initialDrawColor = e.target.value;
        if (currentTool !== 'erase') { 
            currentColor = initialDrawColor;
        }
    });

    clearButton.addEventListener('click', () => {
        const pixels = document.querySelectorAll('.pixel');
        pixels.forEach(pixel => {
            pixel.style.backgroundColor = '#ffffff';
        });
    });

    gridSizeInput.addEventListener('change', (e) => {
        let newSize = parseInt(e.target.value);
        if (newSize < 1 || newSize > 50) {
            newSize = 10;
            gridSizeInput.value = 10;
        }
        
        pixelSize = newSize;
        generateGrid(pixelSize);
    });

    window.addEventListener('resize', () => {
        generateGrid(pixelSize);
    });

    // --- Inicialización ---

    generateGrid(pixelSize);
});</script>